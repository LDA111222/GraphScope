// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct OperationPb {
    // message fields
    pub partitionKey: i64,
    pub opType: OpTypePb,
    pub dataBytes: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OperationPb {
    pub fn new() -> OperationPb {
        ::std::default::Default::default()
    }

    // int64 partitionKey = 1;

    pub fn clear_partitionKey(&mut self) {
        self.partitionKey = 0;
    }

    // Param is passed by value, moved
    pub fn set_partitionKey(&mut self, v: i64) {
        self.partitionKey = v;
    }

    pub fn get_partitionKey(&self) -> i64 {
        self.partitionKey
    }

    // .OpTypePb opType = 2;

    pub fn clear_opType(&mut self) {
        self.opType = OpTypePb::MARKER;
    }

    // Param is passed by value, moved
    pub fn set_opType(&mut self, v: OpTypePb) {
        self.opType = v;
    }

    pub fn get_opType(&self) -> OpTypePb {
        self.opType
    }

    // bytes dataBytes = 3;

    pub fn clear_dataBytes(&mut self) {
        self.dataBytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.dataBytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dataBytes
    }

    // Take field
    pub fn take_dataBytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dataBytes, ::std::vec::Vec::new())
    }

    pub fn get_dataBytes(&self) -> &[u8] {
        &self.dataBytes
    }
}

impl ::protobuf::Message for OperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.partitionKey = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.opType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dataBytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.partitionKey != 0 {
            my_size += ::protobuf::rt::value_size(1, self.partitionKey, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.opType != OpTypePb::MARKER {
            my_size += ::protobuf::rt::enum_size(2, self.opType);
        }
        if !self.dataBytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.dataBytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.partitionKey != 0 {
            os.write_int64(1, self.partitionKey)?;
        }
        if self.opType != OpTypePb::MARKER {
            os.write_enum(2, self.opType.value())?;
        }
        if !self.dataBytes.is_empty() {
            os.write_bytes(3, &self.dataBytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationPb {
        OperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "partitionKey",
                    |m: &OperationPb| { &m.partitionKey },
                    |m: &mut OperationPb| { &mut m.partitionKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpTypePb>>(
                    "opType",
                    |m: &OperationPb| { &m.opType },
                    |m: &mut OperationPb| { &mut m.opType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dataBytes",
                    |m: &OperationPb| { &m.dataBytes },
                    |m: &mut OperationPb| { &mut m.dataBytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationPb>(
                    "OperationPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationPb {
        static mut instance: ::protobuf::lazy::Lazy<OperationPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationPb,
        };
        unsafe {
            instance.get(OperationPb::new)
        }
    }
}

impl ::protobuf::Clear for OperationPb {
    fn clear(&mut self) {
        self.clear_partitionKey();
        self.clear_opType();
        self.clear_dataBytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationBatchPb {
    // message fields
    pub latestSnapshotId: i64,
    pub operations: ::protobuf::RepeatedField<OperationPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OperationBatchPb {
    pub fn new() -> OperationBatchPb {
        ::std::default::Default::default()
    }

    // int64 latestSnapshotId = 1;

    pub fn clear_latestSnapshotId(&mut self) {
        self.latestSnapshotId = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestSnapshotId(&mut self, v: i64) {
        self.latestSnapshotId = v;
    }

    pub fn get_latestSnapshotId(&self) -> i64 {
        self.latestSnapshotId
    }

    // repeated .OperationPb operations = 2;

    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<OperationPb>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<OperationPb> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<OperationPb> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    pub fn get_operations(&self) -> &[OperationPb] {
        &self.operations
    }
}

impl ::protobuf::Message for OperationBatchPb {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latestSnapshotId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latestSnapshotId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.latestSnapshotId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.latestSnapshotId != 0 {
            os.write_int64(1, self.latestSnapshotId)?;
        }
        for v in &self.operations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationBatchPb {
        OperationBatchPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "latestSnapshotId",
                    |m: &OperationBatchPb| { &m.latestSnapshotId },
                    |m: &mut OperationBatchPb| { &mut m.latestSnapshotId },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationPb>>(
                    "operations",
                    |m: &OperationBatchPb| { &m.operations },
                    |m: &mut OperationBatchPb| { &mut m.operations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationBatchPb>(
                    "OperationBatchPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationBatchPb {
        static mut instance: ::protobuf::lazy::Lazy<OperationBatchPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationBatchPb,
        };
        unsafe {
            instance.get(OperationBatchPb::new)
        }
    }
}

impl ::protobuf::Clear for OperationBatchPb {
    fn clear(&mut self) {
        self.clear_latestSnapshotId();
        self.clear_operations();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationBatchPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationBatchPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogEntryPb {
    // message fields
    pub snapshotId: i64,
    pub operations: ::protobuf::SingularPtrField<OperationBatchPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LogEntryPb {
    pub fn new() -> LogEntryPb {
        ::std::default::Default::default()
    }

    // int64 snapshotId = 1;

    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: i64) {
        self.snapshotId = v;
    }

    pub fn get_snapshotId(&self) -> i64 {
        self.snapshotId
    }

    // .OperationBatchPb operations = 2;

    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    pub fn has_operations(&self) -> bool {
        self.operations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: OperationBatchPb) {
        self.operations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operations(&mut self) -> &mut OperationBatchPb {
        if self.operations.is_none() {
            self.operations.set_default();
        }
        self.operations.as_mut().unwrap()
    }

    // Take field
    pub fn take_operations(&mut self) -> OperationBatchPb {
        self.operations.take().unwrap_or_else(|| OperationBatchPb::new())
    }

    pub fn get_operations(&self) -> &OperationBatchPb {
        self.operations.as_ref().unwrap_or_else(|| OperationBatchPb::default_instance())
    }
}

impl ::protobuf::Message for LogEntryPb {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshotId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshotId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshotId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.operations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshotId != 0 {
            os.write_int64(1, self.snapshotId)?;
        }
        if let Some(ref v) = self.operations.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEntryPb {
        LogEntryPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshotId",
                    |m: &LogEntryPb| { &m.snapshotId },
                    |m: &mut LogEntryPb| { &mut m.snapshotId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationBatchPb>>(
                    "operations",
                    |m: &LogEntryPb| { &m.operations },
                    |m: &mut LogEntryPb| { &mut m.operations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogEntryPb>(
                    "LogEntryPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogEntryPb {
        static mut instance: ::protobuf::lazy::Lazy<LogEntryPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogEntryPb,
        };
        unsafe {
            instance.get(LogEntryPb::new)
        }
    }
}

impl ::protobuf::Clear for LogEntryPb {
    fn clear(&mut self) {
        self.clear_snapshotId();
        self.clear_operations();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEntryPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEntryPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MarkerOperationPb {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MarkerOperationPb {
    pub fn new() -> MarkerOperationPb {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MarkerOperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarkerOperationPb {
        MarkerOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MarkerOperationPb>(
                    "MarkerOperationPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MarkerOperationPb {
        static mut instance: ::protobuf::lazy::Lazy<MarkerOperationPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MarkerOperationPb,
        };
        unsafe {
            instance.get(MarkerOperationPb::new)
        }
    }
}

impl ::protobuf::Clear for MarkerOperationPb {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarkerOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkerOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyValuePb {
    // message fields
    pub dataType: DataTypePb,
    pub val: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PropertyValuePb {
    pub fn new() -> PropertyValuePb {
        ::std::default::Default::default()
    }

    // .DataTypePb dataType = 1;

    pub fn clear_dataType(&mut self) {
        self.dataType = DataTypePb::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: DataTypePb) {
        self.dataType = v;
    }

    pub fn get_dataType(&self) -> DataTypePb {
        self.dataType
    }

    // bytes val = 2;

    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<u8>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }

    pub fn get_val(&self) -> &[u8] {
        &self.val
    }
}

impl ::protobuf::Message for PropertyValuePb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.val)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dataType != DataTypePb::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.dataType);
        }
        if !self.val.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.val);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.dataType != DataTypePb::UNKNOWN {
            os.write_enum(1, self.dataType.value())?;
        }
        if !self.val.is_empty() {
            os.write_bytes(2, &self.val)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyValuePb {
        PropertyValuePb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataTypePb>>(
                    "dataType",
                    |m: &PropertyValuePb| { &m.dataType },
                    |m: &mut PropertyValuePb| { &mut m.dataType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "val",
                    |m: &PropertyValuePb| { &m.val },
                    |m: &mut PropertyValuePb| { &mut m.val },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PropertyValuePb>(
                    "PropertyValuePb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PropertyValuePb {
        static mut instance: ::protobuf::lazy::Lazy<PropertyValuePb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PropertyValuePb,
        };
        unsafe {
            instance.get(PropertyValuePb::new)
        }
    }
}

impl ::protobuf::Clear for PropertyValuePb {
    fn clear(&mut self) {
        self.clear_dataType();
        self.clear_val();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyValuePb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyValuePb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexIdPb {
    // message fields
    pub id: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VertexIdPb {
    pub fn new() -> VertexIdPb {
        ::std::default::Default::default()
    }

    // int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }
}

impl ::protobuf::Message for VertexIdPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexIdPb {
        VertexIdPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &VertexIdPb| { &m.id },
                    |m: &mut VertexIdPb| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VertexIdPb>(
                    "VertexIdPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexIdPb {
        static mut instance: ::protobuf::lazy::Lazy<VertexIdPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VertexIdPb,
        };
        unsafe {
            instance.get(VertexIdPb::new)
        }
    }
}

impl ::protobuf::Clear for VertexIdPb {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexIdPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexIdPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeIdPb {
    // message fields
    pub srcId: ::protobuf::SingularPtrField<VertexIdPb>,
    pub dstId: ::protobuf::SingularPtrField<VertexIdPb>,
    pub id: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeIdPb {
    pub fn new() -> EdgeIdPb {
        ::std::default::Default::default()
    }

    // .VertexIdPb srcId = 1;

    pub fn clear_srcId(&mut self) {
        self.srcId.clear();
    }

    pub fn has_srcId(&self) -> bool {
        self.srcId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcId(&mut self, v: VertexIdPb) {
        self.srcId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcId(&mut self) -> &mut VertexIdPb {
        if self.srcId.is_none() {
            self.srcId.set_default();
        }
        self.srcId.as_mut().unwrap()
    }

    // Take field
    pub fn take_srcId(&mut self) -> VertexIdPb {
        self.srcId.take().unwrap_or_else(|| VertexIdPb::new())
    }

    pub fn get_srcId(&self) -> &VertexIdPb {
        self.srcId.as_ref().unwrap_or_else(|| VertexIdPb::default_instance())
    }

    // .VertexIdPb dstId = 2;

    pub fn clear_dstId(&mut self) {
        self.dstId.clear();
    }

    pub fn has_dstId(&self) -> bool {
        self.dstId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dstId(&mut self, v: VertexIdPb) {
        self.dstId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dstId(&mut self) -> &mut VertexIdPb {
        if self.dstId.is_none() {
            self.dstId.set_default();
        }
        self.dstId.as_mut().unwrap()
    }

    // Take field
    pub fn take_dstId(&mut self) -> VertexIdPb {
        self.dstId.take().unwrap_or_else(|| VertexIdPb::new())
    }

    pub fn get_dstId(&self) -> &VertexIdPb {
        self.dstId.as_ref().unwrap_or_else(|| VertexIdPb::default_instance())
    }

    // int64 id = 3;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }
}

impl ::protobuf::Message for EdgeIdPb {
    fn is_initialized(&self) -> bool {
        for v in &self.srcId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dstId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.srcId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dstId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.srcId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dstId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.srcId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dstId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.id != 0 {
            os.write_int64(3, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeIdPb {
        EdgeIdPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexIdPb>>(
                    "srcId",
                    |m: &EdgeIdPb| { &m.srcId },
                    |m: &mut EdgeIdPb| { &mut m.srcId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexIdPb>>(
                    "dstId",
                    |m: &EdgeIdPb| { &m.dstId },
                    |m: &mut EdgeIdPb| { &mut m.dstId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &EdgeIdPb| { &m.id },
                    |m: &mut EdgeIdPb| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeIdPb>(
                    "EdgeIdPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeIdPb {
        static mut instance: ::protobuf::lazy::Lazy<EdgeIdPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeIdPb,
        };
        unsafe {
            instance.get(EdgeIdPb::new)
        }
    }
}

impl ::protobuf::Clear for EdgeIdPb {
    fn clear(&mut self) {
        self.clear_srcId();
        self.clear_dstId();
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeIdPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeIdPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelIdPb {
    // message fields
    pub id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LabelIdPb {
    pub fn new() -> LabelIdPb {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }
}

impl ::protobuf::Message for LabelIdPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelIdPb {
        LabelIdPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &LabelIdPb| { &m.id },
                    |m: &mut LabelIdPb| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LabelIdPb>(
                    "LabelIdPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LabelIdPb {
        static mut instance: ::protobuf::lazy::Lazy<LabelIdPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LabelIdPb,
        };
        unsafe {
            instance.get(LabelIdPb::new)
        }
    }
}

impl ::protobuf::Clear for LabelIdPb {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelIdPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelIdPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeKindPb {
    // message fields
    pub edgeLabel: ::std::string::String,
    pub edgeLabelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub srcVertexLabel: ::std::string::String,
    pub srcVertexLabelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub dstVertexLabel: ::std::string::String,
    pub dstVertexLabelId: ::protobuf::SingularPtrField<LabelIdPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeKindPb {
    pub fn new() -> EdgeKindPb {
        ::std::default::Default::default()
    }

    // string edgeLabel = 1;

    pub fn clear_edgeLabel(&mut self) {
        self.edgeLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_edgeLabel(&mut self, v: ::std::string::String) {
        self.edgeLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabel(&mut self) -> &mut ::std::string::String {
        &mut self.edgeLabel
    }

    // Take field
    pub fn take_edgeLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.edgeLabel, ::std::string::String::new())
    }

    pub fn get_edgeLabel(&self) -> &str {
        &self.edgeLabel
    }

    // .LabelIdPb edgeLabelId = 2;

    pub fn clear_edgeLabelId(&mut self) {
        self.edgeLabelId.clear();
    }

    pub fn has_edgeLabelId(&self) -> bool {
        self.edgeLabelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeLabelId(&mut self, v: LabelIdPb) {
        self.edgeLabelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabelId(&mut self) -> &mut LabelIdPb {
        if self.edgeLabelId.is_none() {
            self.edgeLabelId.set_default();
        }
        self.edgeLabelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeLabelId(&mut self) -> LabelIdPb {
        self.edgeLabelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    pub fn get_edgeLabelId(&self) -> &LabelIdPb {
        self.edgeLabelId.as_ref().unwrap_or_else(|| LabelIdPb::default_instance())
    }

    // string srcVertexLabel = 3;

    pub fn clear_srcVertexLabel(&mut self) {
        self.srcVertexLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcVertexLabel(&mut self, v: ::std::string::String) {
        self.srcVertexLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcVertexLabel(&mut self) -> &mut ::std::string::String {
        &mut self.srcVertexLabel
    }

    // Take field
    pub fn take_srcVertexLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.srcVertexLabel, ::std::string::String::new())
    }

    pub fn get_srcVertexLabel(&self) -> &str {
        &self.srcVertexLabel
    }

    // .LabelIdPb srcVertexLabelId = 4;

    pub fn clear_srcVertexLabelId(&mut self) {
        self.srcVertexLabelId.clear();
    }

    pub fn has_srcVertexLabelId(&self) -> bool {
        self.srcVertexLabelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcVertexLabelId(&mut self, v: LabelIdPb) {
        self.srcVertexLabelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcVertexLabelId(&mut self) -> &mut LabelIdPb {
        if self.srcVertexLabelId.is_none() {
            self.srcVertexLabelId.set_default();
        }
        self.srcVertexLabelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_srcVertexLabelId(&mut self) -> LabelIdPb {
        self.srcVertexLabelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    pub fn get_srcVertexLabelId(&self) -> &LabelIdPb {
        self.srcVertexLabelId.as_ref().unwrap_or_else(|| LabelIdPb::default_instance())
    }

    // string dstVertexLabel = 5;

    pub fn clear_dstVertexLabel(&mut self) {
        self.dstVertexLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_dstVertexLabel(&mut self, v: ::std::string::String) {
        self.dstVertexLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dstVertexLabel(&mut self) -> &mut ::std::string::String {
        &mut self.dstVertexLabel
    }

    // Take field
    pub fn take_dstVertexLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dstVertexLabel, ::std::string::String::new())
    }

    pub fn get_dstVertexLabel(&self) -> &str {
        &self.dstVertexLabel
    }

    // .LabelIdPb dstVertexLabelId = 6;

    pub fn clear_dstVertexLabelId(&mut self) {
        self.dstVertexLabelId.clear();
    }

    pub fn has_dstVertexLabelId(&self) -> bool {
        self.dstVertexLabelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dstVertexLabelId(&mut self, v: LabelIdPb) {
        self.dstVertexLabelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dstVertexLabelId(&mut self) -> &mut LabelIdPb {
        if self.dstVertexLabelId.is_none() {
            self.dstVertexLabelId.set_default();
        }
        self.dstVertexLabelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_dstVertexLabelId(&mut self) -> LabelIdPb {
        self.dstVertexLabelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    pub fn get_dstVertexLabelId(&self) -> &LabelIdPb {
        self.dstVertexLabelId.as_ref().unwrap_or_else(|| LabelIdPb::default_instance())
    }
}

impl ::protobuf::Message for EdgeKindPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeLabelId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.srcVertexLabelId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dstVertexLabelId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.edgeLabel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeLabelId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.srcVertexLabel)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.srcVertexLabelId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dstVertexLabel)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dstVertexLabelId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.edgeLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.edgeLabel);
        }
        if let Some(ref v) = self.edgeLabelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.srcVertexLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.srcVertexLabel);
        }
        if let Some(ref v) = self.srcVertexLabelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dstVertexLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dstVertexLabel);
        }
        if let Some(ref v) = self.dstVertexLabelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.edgeLabel.is_empty() {
            os.write_string(1, &self.edgeLabel)?;
        }
        if let Some(ref v) = self.edgeLabelId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.srcVertexLabel.is_empty() {
            os.write_string(3, &self.srcVertexLabel)?;
        }
        if let Some(ref v) = self.srcVertexLabelId.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dstVertexLabel.is_empty() {
            os.write_string(5, &self.dstVertexLabel)?;
        }
        if let Some(ref v) = self.dstVertexLabelId.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeKindPb {
        EdgeKindPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "edgeLabel",
                    |m: &EdgeKindPb| { &m.edgeLabel },
                    |m: &mut EdgeKindPb| { &mut m.edgeLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                    "edgeLabelId",
                    |m: &EdgeKindPb| { &m.edgeLabelId },
                    |m: &mut EdgeKindPb| { &mut m.edgeLabelId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "srcVertexLabel",
                    |m: &EdgeKindPb| { &m.srcVertexLabel },
                    |m: &mut EdgeKindPb| { &mut m.srcVertexLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                    "srcVertexLabelId",
                    |m: &EdgeKindPb| { &m.srcVertexLabelId },
                    |m: &mut EdgeKindPb| { &mut m.srcVertexLabelId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dstVertexLabel",
                    |m: &EdgeKindPb| { &m.dstVertexLabel },
                    |m: &mut EdgeKindPb| { &mut m.dstVertexLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                    "dstVertexLabelId",
                    |m: &EdgeKindPb| { &m.dstVertexLabelId },
                    |m: &mut EdgeKindPb| { &mut m.dstVertexLabelId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeKindPb>(
                    "EdgeKindPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeKindPb {
        static mut instance: ::protobuf::lazy::Lazy<EdgeKindPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeKindPb,
        };
        unsafe {
            instance.get(EdgeKindPb::new)
        }
    }
}

impl ::protobuf::Clear for EdgeKindPb {
    fn clear(&mut self) {
        self.clear_edgeLabel();
        self.clear_edgeLabelId();
        self.clear_srcVertexLabel();
        self.clear_srcVertexLabelId();
        self.clear_dstVertexLabel();
        self.clear_dstVertexLabelId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeKindPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeKindPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataOperationPb {
    // message fields
    pub keyBlob: ::std::vec::Vec<u8>,
    pub locationBlob: ::std::vec::Vec<u8>,
    pub props: ::std::collections::HashMap<i32, PropertyValuePb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DataOperationPb {
    pub fn new() -> DataOperationPb {
        ::std::default::Default::default()
    }

    // bytes keyBlob = 1;

    pub fn clear_keyBlob(&mut self) {
        self.keyBlob.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyBlob(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyBlob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyBlob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.keyBlob
    }

    // Take field
    pub fn take_keyBlob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.keyBlob, ::std::vec::Vec::new())
    }

    pub fn get_keyBlob(&self) -> &[u8] {
        &self.keyBlob
    }

    // bytes locationBlob = 2;

    pub fn clear_locationBlob(&mut self) {
        self.locationBlob.clear();
    }

    // Param is passed by value, moved
    pub fn set_locationBlob(&mut self, v: ::std::vec::Vec<u8>) {
        self.locationBlob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locationBlob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.locationBlob
    }

    // Take field
    pub fn take_locationBlob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.locationBlob, ::std::vec::Vec::new())
    }

    pub fn get_locationBlob(&self) -> &[u8] {
        &self.locationBlob
    }

    // repeated .DataOperationPb.PropsEntry props = 3;

    pub fn clear_props(&mut self) {
        self.props.clear();
    }

    // Param is passed by value, moved
    pub fn set_props(&mut self, v: ::std::collections::HashMap<i32, PropertyValuePb>) {
        self.props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_props(&mut self) -> &mut ::std::collections::HashMap<i32, PropertyValuePb> {
        &mut self.props
    }

    // Take field
    pub fn take_props(&mut self) -> ::std::collections::HashMap<i32, PropertyValuePb> {
        ::std::mem::replace(&mut self.props, ::std::collections::HashMap::new())
    }

    pub fn get_props(&self) -> &::std::collections::HashMap<i32, PropertyValuePb> {
        &self.props
    }
}

impl ::protobuf::Message for DataOperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.keyBlob)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.locationBlob)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(wire_type, is, &mut self.props)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.keyBlob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.keyBlob);
        }
        if !self.locationBlob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.locationBlob);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(3, &self.props);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.keyBlob.is_empty() {
            os.write_bytes(1, &self.keyBlob)?;
        }
        if !self.locationBlob.is_empty() {
            os.write_bytes(2, &self.locationBlob)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(3, &self.props, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataOperationPb {
        DataOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "keyBlob",
                    |m: &DataOperationPb| { &m.keyBlob },
                    |m: &mut DataOperationPb| { &mut m.keyBlob },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "locationBlob",
                    |m: &DataOperationPb| { &m.locationBlob },
                    |m: &mut DataOperationPb| { &mut m.locationBlob },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(
                    "props",
                    |m: &DataOperationPb| { &m.props },
                    |m: &mut DataOperationPb| { &mut m.props },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataOperationPb>(
                    "DataOperationPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataOperationPb {
        static mut instance: ::protobuf::lazy::Lazy<DataOperationPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataOperationPb,
        };
        unsafe {
            instance.get(DataOperationPb::new)
        }
    }
}

impl ::protobuf::Clear for DataOperationPb {
    fn clear(&mut self) {
        self.clear_keyBlob();
        self.clear_locationBlob();
        self.clear_props();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KindOperationPb {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl KindOperationPb {
    pub fn new() -> KindOperationPb {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;

    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }

    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| EdgeKindPb::default_instance())
    }
}

impl ::protobuf::Message for KindOperationPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KindOperationPb {
        KindOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                    "edgeKind",
                    |m: &KindOperationPb| { &m.edgeKind },
                    |m: &mut KindOperationPb| { &mut m.edgeKind },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KindOperationPb>(
                    "KindOperationPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KindOperationPb {
        static mut instance: ::protobuf::lazy::Lazy<KindOperationPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KindOperationPb,
        };
        unsafe {
            instance.get(KindOperationPb::new)
        }
    }
}

impl ::protobuf::Clear for KindOperationPb {
    fn clear(&mut self) {
        self.clear_edgeKind();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KindOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KindOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeDefPb {
    // message fields
    pub versionId: i32,
    pub label: ::std::string::String,
    pub labelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub typeEnum: TypeEnumPb,
    pub props: ::protobuf::RepeatedField<PropertyDefPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TypeDefPb {
    pub fn new() -> TypeDefPb {
        ::std::default::Default::default()
    }

    // int32 versionId = 1;

    pub fn clear_versionId(&mut self) {
        self.versionId = 0;
    }

    // Param is passed by value, moved
    pub fn set_versionId(&mut self, v: i32) {
        self.versionId = v;
    }

    pub fn get_versionId(&self) -> i32 {
        self.versionId
    }

    // string label = 2;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        &self.label
    }

    // .LabelIdPb labelId = 3;

    pub fn clear_labelId(&mut self) {
        self.labelId.clear();
    }

    pub fn has_labelId(&self) -> bool {
        self.labelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelId(&mut self, v: LabelIdPb) {
        self.labelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelId(&mut self) -> &mut LabelIdPb {
        if self.labelId.is_none() {
            self.labelId.set_default();
        }
        self.labelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelId(&mut self) -> LabelIdPb {
        self.labelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    pub fn get_labelId(&self) -> &LabelIdPb {
        self.labelId.as_ref().unwrap_or_else(|| LabelIdPb::default_instance())
    }

    // .TypeEnumPb typeEnum = 4;

    pub fn clear_typeEnum(&mut self) {
        self.typeEnum = TypeEnumPb::VERTEX;
    }

    // Param is passed by value, moved
    pub fn set_typeEnum(&mut self, v: TypeEnumPb) {
        self.typeEnum = v;
    }

    pub fn get_typeEnum(&self) -> TypeEnumPb {
        self.typeEnum
    }

    // repeated .PropertyDefPb props = 5;

    pub fn clear_props(&mut self) {
        self.props.clear();
    }

    // Param is passed by value, moved
    pub fn set_props(&mut self, v: ::protobuf::RepeatedField<PropertyDefPb>) {
        self.props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_props(&mut self) -> &mut ::protobuf::RepeatedField<PropertyDefPb> {
        &mut self.props
    }

    // Take field
    pub fn take_props(&mut self) -> ::protobuf::RepeatedField<PropertyDefPb> {
        ::std::mem::replace(&mut self.props, ::protobuf::RepeatedField::new())
    }

    pub fn get_props(&self) -> &[PropertyDefPb] {
        &self.props
    }
}

impl ::protobuf::Message for TypeDefPb {
    fn is_initialized(&self) -> bool {
        for v in &self.labelId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.props {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelId)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.typeEnum, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.props)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.versionId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.versionId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if let Some(ref v) = self.labelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.typeEnum != TypeEnumPb::VERTEX {
            my_size += ::protobuf::rt::enum_size(4, self.typeEnum);
        }
        for value in &self.props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.versionId != 0 {
            os.write_int32(1, self.versionId)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if let Some(ref v) = self.labelId.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.typeEnum != TypeEnumPb::VERTEX {
            os.write_enum(4, self.typeEnum.value())?;
        }
        for v in &self.props {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeDefPb {
        TypeDefPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "versionId",
                    |m: &TypeDefPb| { &m.versionId },
                    |m: &mut TypeDefPb| { &mut m.versionId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &TypeDefPb| { &m.label },
                    |m: &mut TypeDefPb| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                    "labelId",
                    |m: &TypeDefPb| { &m.labelId },
                    |m: &mut TypeDefPb| { &mut m.labelId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypeEnumPb>>(
                    "typeEnum",
                    |m: &TypeDefPb| { &m.typeEnum },
                    |m: &mut TypeDefPb| { &mut m.typeEnum },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyDefPb>>(
                    "props",
                    |m: &TypeDefPb| { &m.props },
                    |m: &mut TypeDefPb| { &mut m.props },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeDefPb>(
                    "TypeDefPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeDefPb {
        static mut instance: ::protobuf::lazy::Lazy<TypeDefPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeDefPb,
        };
        unsafe {
            instance.get(TypeDefPb::new)
        }
    }
}

impl ::protobuf::Clear for TypeDefPb {
    fn clear(&mut self) {
        self.clear_versionId();
        self.clear_label();
        self.clear_labelId();
        self.clear_typeEnum();
        self.clear_props();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeDefPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeDefPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyDefPb {
    // message fields
    pub id: i32,
    pub innerId: i32,
    pub name: ::std::string::String,
    pub dataType: DataTypePb,
    pub defaultValue: ::protobuf::SingularPtrField<PropertyValuePb>,
    pub pk: bool,
    pub comment: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PropertyDefPb {
    pub fn new() -> PropertyDefPb {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }

    // int32 innerId = 2;

    pub fn clear_innerId(&mut self) {
        self.innerId = 0;
    }

    // Param is passed by value, moved
    pub fn set_innerId(&mut self, v: i32) {
        self.innerId = v;
    }

    pub fn get_innerId(&self) -> i32 {
        self.innerId
    }

    // string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .DataTypePb dataType = 4;

    pub fn clear_dataType(&mut self) {
        self.dataType = DataTypePb::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: DataTypePb) {
        self.dataType = v;
    }

    pub fn get_dataType(&self) -> DataTypePb {
        self.dataType
    }

    // .PropertyValuePb defaultValue = 5;

    pub fn clear_defaultValue(&mut self) {
        self.defaultValue.clear();
    }

    pub fn has_defaultValue(&self) -> bool {
        self.defaultValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultValue(&mut self, v: PropertyValuePb) {
        self.defaultValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultValue(&mut self) -> &mut PropertyValuePb {
        if self.defaultValue.is_none() {
            self.defaultValue.set_default();
        }
        self.defaultValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_defaultValue(&mut self) -> PropertyValuePb {
        self.defaultValue.take().unwrap_or_else(|| PropertyValuePb::new())
    }

    pub fn get_defaultValue(&self) -> &PropertyValuePb {
        self.defaultValue.as_ref().unwrap_or_else(|| PropertyValuePb::default_instance())
    }

    // bool pk = 6;

    pub fn clear_pk(&mut self) {
        self.pk = false;
    }

    // Param is passed by value, moved
    pub fn set_pk(&mut self, v: bool) {
        self.pk = v;
    }

    pub fn get_pk(&self) -> bool {
        self.pk
    }

    // string comment = 7;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        &self.comment
    }
}

impl ::protobuf::Message for PropertyDefPb {
    fn is_initialized(&self) -> bool {
        for v in &self.defaultValue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.innerId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defaultValue)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pk = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.innerId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.innerId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.dataType != DataTypePb::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.dataType);
        }
        if let Some(ref v) = self.defaultValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.pk != false {
            my_size += 2;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.comment);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.innerId != 0 {
            os.write_int32(2, self.innerId)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.dataType != DataTypePb::UNKNOWN {
            os.write_enum(4, self.dataType.value())?;
        }
        if let Some(ref v) = self.defaultValue.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.pk != false {
            os.write_bool(6, self.pk)?;
        }
        if !self.comment.is_empty() {
            os.write_string(7, &self.comment)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyDefPb {
        PropertyDefPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &PropertyDefPb| { &m.id },
                    |m: &mut PropertyDefPb| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "innerId",
                    |m: &PropertyDefPb| { &m.innerId },
                    |m: &mut PropertyDefPb| { &mut m.innerId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &PropertyDefPb| { &m.name },
                    |m: &mut PropertyDefPb| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataTypePb>>(
                    "dataType",
                    |m: &PropertyDefPb| { &m.dataType },
                    |m: &mut PropertyDefPb| { &mut m.dataType },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(
                    "defaultValue",
                    |m: &PropertyDefPb| { &m.defaultValue },
                    |m: &mut PropertyDefPb| { &mut m.defaultValue },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pk",
                    |m: &PropertyDefPb| { &m.pk },
                    |m: &mut PropertyDefPb| { &mut m.pk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    |m: &PropertyDefPb| { &m.comment },
                    |m: &mut PropertyDefPb| { &mut m.comment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PropertyDefPb>(
                    "PropertyDefPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PropertyDefPb {
        static mut instance: ::protobuf::lazy::Lazy<PropertyDefPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PropertyDefPb,
        };
        unsafe {
            instance.get(PropertyDefPb::new)
        }
    }
}

impl ::protobuf::Clear for PropertyDefPb {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_innerId();
        self.clear_name();
        self.clear_dataType();
        self.clear_defaultValue();
        self.clear_pk();
        self.clear_comment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyDefPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyDefPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlRequestPb {
    // message fields
    pub opType: OpTypePb,
    pub ddlBytes: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DdlRequestPb {
    pub fn new() -> DdlRequestPb {
        ::std::default::Default::default()
    }

    // .OpTypePb opType = 1;

    pub fn clear_opType(&mut self) {
        self.opType = OpTypePb::MARKER;
    }

    // Param is passed by value, moved
    pub fn set_opType(&mut self, v: OpTypePb) {
        self.opType = v;
    }

    pub fn get_opType(&self) -> OpTypePb {
        self.opType
    }

    // bytes ddlBytes = 2;

    pub fn clear_ddlBytes(&mut self) {
        self.ddlBytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_ddlBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.ddlBytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ddlBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ddlBytes
    }

    // Take field
    pub fn take_ddlBytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ddlBytes, ::std::vec::Vec::new())
    }

    pub fn get_ddlBytes(&self) -> &[u8] {
        &self.ddlBytes
    }
}

impl ::protobuf::Message for DdlRequestPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.opType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ddlBytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.opType != OpTypePb::MARKER {
            my_size += ::protobuf::rt::enum_size(1, self.opType);
        }
        if !self.ddlBytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ddlBytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.opType != OpTypePb::MARKER {
            os.write_enum(1, self.opType.value())?;
        }
        if !self.ddlBytes.is_empty() {
            os.write_bytes(2, &self.ddlBytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlRequestPb {
        DdlRequestPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpTypePb>>(
                    "opType",
                    |m: &DdlRequestPb| { &m.opType },
                    |m: &mut DdlRequestPb| { &mut m.opType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ddlBytes",
                    |m: &DdlRequestPb| { &m.ddlBytes },
                    |m: &mut DdlRequestPb| { &mut m.ddlBytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DdlRequestPb>(
                    "DdlRequestPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DdlRequestPb {
        static mut instance: ::protobuf::lazy::Lazy<DdlRequestPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DdlRequestPb,
        };
        unsafe {
            instance.get(DdlRequestPb::new)
        }
    }
}

impl ::protobuf::Clear for DdlRequestPb {
    fn clear(&mut self) {
        self.clear_opType();
        self.clear_ddlBytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlRequestPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlRequestPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlRequestBatchPb {
    // message fields
    pub ddlRequests: ::protobuf::RepeatedField<DdlRequestPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DdlRequestBatchPb {
    pub fn new() -> DdlRequestBatchPb {
        ::std::default::Default::default()
    }

    // repeated .DdlRequestPb ddlRequests = 1;

    pub fn clear_ddlRequests(&mut self) {
        self.ddlRequests.clear();
    }

    // Param is passed by value, moved
    pub fn set_ddlRequests(&mut self, v: ::protobuf::RepeatedField<DdlRequestPb>) {
        self.ddlRequests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ddlRequests(&mut self) -> &mut ::protobuf::RepeatedField<DdlRequestPb> {
        &mut self.ddlRequests
    }

    // Take field
    pub fn take_ddlRequests(&mut self) -> ::protobuf::RepeatedField<DdlRequestPb> {
        ::std::mem::replace(&mut self.ddlRequests, ::protobuf::RepeatedField::new())
    }

    pub fn get_ddlRequests(&self) -> &[DdlRequestPb] {
        &self.ddlRequests
    }
}

impl ::protobuf::Message for DdlRequestBatchPb {
    fn is_initialized(&self) -> bool {
        for v in &self.ddlRequests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ddlRequests)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ddlRequests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ddlRequests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlRequestBatchPb {
        DdlRequestBatchPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DdlRequestPb>>(
                    "ddlRequests",
                    |m: &DdlRequestBatchPb| { &m.ddlRequests },
                    |m: &mut DdlRequestBatchPb| { &mut m.ddlRequests },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DdlRequestBatchPb>(
                    "DdlRequestBatchPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DdlRequestBatchPb {
        static mut instance: ::protobuf::lazy::Lazy<DdlRequestBatchPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DdlRequestBatchPb,
        };
        unsafe {
            instance.get(DdlRequestBatchPb::new)
        }
    }
}

impl ::protobuf::Clear for DdlRequestBatchPb {
    fn clear(&mut self) {
        self.clear_ddlRequests();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlRequestBatchPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlRequestBatchPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlOperationPb {
    // message fields
    pub schemaVersion: i64,
    pub ddlBlob: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DdlOperationPb {
    pub fn new() -> DdlOperationPb {
        ::std::default::Default::default()
    }

    // int64 schemaVersion = 1;

    pub fn clear_schemaVersion(&mut self) {
        self.schemaVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_schemaVersion(&mut self, v: i64) {
        self.schemaVersion = v;
    }

    pub fn get_schemaVersion(&self) -> i64 {
        self.schemaVersion
    }

    // bytes ddlBlob = 2;

    pub fn clear_ddlBlob(&mut self) {
        self.ddlBlob.clear();
    }

    // Param is passed by value, moved
    pub fn set_ddlBlob(&mut self, v: ::std::vec::Vec<u8>) {
        self.ddlBlob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ddlBlob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ddlBlob
    }

    // Take field
    pub fn take_ddlBlob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ddlBlob, ::std::vec::Vec::new())
    }

    pub fn get_ddlBlob(&self) -> &[u8] {
        &self.ddlBlob
    }
}

impl ::protobuf::Message for DdlOperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.schemaVersion = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ddlBlob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.schemaVersion != 0 {
            my_size += ::protobuf::rt::value_size(1, self.schemaVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ddlBlob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ddlBlob);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.schemaVersion != 0 {
            os.write_int64(1, self.schemaVersion)?;
        }
        if !self.ddlBlob.is_empty() {
            os.write_bytes(2, &self.ddlBlob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlOperationPb {
        DdlOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "schemaVersion",
                    |m: &DdlOperationPb| { &m.schemaVersion },
                    |m: &mut DdlOperationPb| { &mut m.schemaVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ddlBlob",
                    |m: &DdlOperationPb| { &m.ddlBlob },
                    |m: &mut DdlOperationPb| { &mut m.ddlBlob },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DdlOperationPb>(
                    "DdlOperationPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DdlOperationPb {
        static mut instance: ::protobuf::lazy::Lazy<DdlOperationPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DdlOperationPb,
        };
        unsafe {
            instance.get(DdlOperationPb::new)
        }
    }
}

impl ::protobuf::Clear for DdlOperationPb {
    fn clear(&mut self) {
        self.clear_schemaVersion();
        self.clear_ddlBlob();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateVertexTypePb {
    // message fields
    pub typeDef: ::protobuf::SingularPtrField<TypeDefPb>,
    pub tableIdx: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateVertexTypePb {
    pub fn new() -> CreateVertexTypePb {
        ::std::default::Default::default()
    }

    // .TypeDefPb typeDef = 1;

    pub fn clear_typeDef(&mut self) {
        self.typeDef.clear();
    }

    pub fn has_typeDef(&self) -> bool {
        self.typeDef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeDef(&mut self, v: TypeDefPb) {
        self.typeDef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeDef(&mut self) -> &mut TypeDefPb {
        if self.typeDef.is_none() {
            self.typeDef.set_default();
        }
        self.typeDef.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeDef(&mut self) -> TypeDefPb {
        self.typeDef.take().unwrap_or_else(|| TypeDefPb::new())
    }

    pub fn get_typeDef(&self) -> &TypeDefPb {
        self.typeDef.as_ref().unwrap_or_else(|| TypeDefPb::default_instance())
    }

    // int64 tableIdx = 2;

    pub fn clear_tableIdx(&mut self) {
        self.tableIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableIdx(&mut self, v: i64) {
        self.tableIdx = v;
    }

    pub fn get_tableIdx(&self) -> i64 {
        self.tableIdx
    }
}

impl ::protobuf::Message for CreateVertexTypePb {
    fn is_initialized(&self) -> bool {
        for v in &self.typeDef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeDef)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.typeDef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableIdx != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.typeDef.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableIdx != 0 {
            os.write_int64(2, self.tableIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateVertexTypePb {
        CreateVertexTypePb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeDefPb>>(
                    "typeDef",
                    |m: &CreateVertexTypePb| { &m.typeDef },
                    |m: &mut CreateVertexTypePb| { &mut m.typeDef },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tableIdx",
                    |m: &CreateVertexTypePb| { &m.tableIdx },
                    |m: &mut CreateVertexTypePb| { &mut m.tableIdx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateVertexTypePb>(
                    "CreateVertexTypePb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateVertexTypePb {
        static mut instance: ::protobuf::lazy::Lazy<CreateVertexTypePb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateVertexTypePb,
        };
        unsafe {
            instance.get(CreateVertexTypePb::new)
        }
    }
}

impl ::protobuf::Clear for CreateVertexTypePb {
    fn clear(&mut self) {
        self.clear_typeDef();
        self.clear_tableIdx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateVertexTypePb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVertexTypePb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddEdgeKindPb {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    pub tableIdx: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AddEdgeKindPb {
    pub fn new() -> AddEdgeKindPb {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;

    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }

    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| EdgeKindPb::default_instance())
    }

    // int64 tableIdx = 2;

    pub fn clear_tableIdx(&mut self) {
        self.tableIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableIdx(&mut self, v: i64) {
        self.tableIdx = v;
    }

    pub fn get_tableIdx(&self) -> i64 {
        self.tableIdx
    }
}

impl ::protobuf::Message for AddEdgeKindPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableIdx != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableIdx != 0 {
            os.write_int64(2, self.tableIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddEdgeKindPb {
        AddEdgeKindPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                    "edgeKind",
                    |m: &AddEdgeKindPb| { &m.edgeKind },
                    |m: &mut AddEdgeKindPb| { &mut m.edgeKind },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tableIdx",
                    |m: &AddEdgeKindPb| { &m.tableIdx },
                    |m: &mut AddEdgeKindPb| { &mut m.tableIdx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddEdgeKindPb>(
                    "AddEdgeKindPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddEdgeKindPb {
        static mut instance: ::protobuf::lazy::Lazy<AddEdgeKindPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddEdgeKindPb,
        };
        unsafe {
            instance.get(AddEdgeKindPb::new)
        }
    }
}

impl ::protobuf::Clear for AddEdgeKindPb {
    fn clear(&mut self) {
        self.clear_edgeKind();
        self.clear_tableIdx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddEdgeKindPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEdgeKindPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeTableIdEntry {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    pub tableId: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeTableIdEntry {
    pub fn new() -> EdgeTableIdEntry {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;

    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }

    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| EdgeKindPb::default_instance())
    }

    // int64 tableId = 2;

    pub fn clear_tableId(&mut self) {
        self.tableId = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: i64) {
        self.tableId = v;
    }

    pub fn get_tableId(&self) -> i64 {
        self.tableId
    }
}

impl ::protobuf::Message for EdgeTableIdEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableId != 0 {
            os.write_int64(2, self.tableId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeTableIdEntry {
        EdgeTableIdEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                    "edgeKind",
                    |m: &EdgeTableIdEntry| { &m.edgeKind },
                    |m: &mut EdgeTableIdEntry| { &mut m.edgeKind },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tableId",
                    |m: &EdgeTableIdEntry| { &m.tableId },
                    |m: &mut EdgeTableIdEntry| { &mut m.tableId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeTableIdEntry>(
                    "EdgeTableIdEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeTableIdEntry {
        static mut instance: ::protobuf::lazy::Lazy<EdgeTableIdEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeTableIdEntry,
        };
        unsafe {
            instance.get(EdgeTableIdEntry::new)
        }
    }
}

impl ::protobuf::Clear for EdgeTableIdEntry {
    fn clear(&mut self) {
        self.clear_edgeKind();
        self.clear_tableId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeTableIdEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeTableIdEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexTableIdEntry {
    // message fields
    pub labelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub tableId: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VertexTableIdEntry {
    pub fn new() -> VertexTableIdEntry {
        ::std::default::Default::default()
    }

    // .LabelIdPb labelId = 1;

    pub fn clear_labelId(&mut self) {
        self.labelId.clear();
    }

    pub fn has_labelId(&self) -> bool {
        self.labelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelId(&mut self, v: LabelIdPb) {
        self.labelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelId(&mut self) -> &mut LabelIdPb {
        if self.labelId.is_none() {
            self.labelId.set_default();
        }
        self.labelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelId(&mut self) -> LabelIdPb {
        self.labelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    pub fn get_labelId(&self) -> &LabelIdPb {
        self.labelId.as_ref().unwrap_or_else(|| LabelIdPb::default_instance())
    }

    // int64 tableId = 2;

    pub fn clear_tableId(&mut self) {
        self.tableId = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: i64) {
        self.tableId = v;
    }

    pub fn get_tableId(&self) -> i64 {
        self.tableId
    }
}

impl ::protobuf::Message for VertexTableIdEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.labelId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.labelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.labelId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableId != 0 {
            os.write_int64(2, self.tableId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexTableIdEntry {
        VertexTableIdEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                    "labelId",
                    |m: &VertexTableIdEntry| { &m.labelId },
                    |m: &mut VertexTableIdEntry| { &mut m.labelId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tableId",
                    |m: &VertexTableIdEntry| { &m.tableId },
                    |m: &mut VertexTableIdEntry| { &mut m.tableId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VertexTableIdEntry>(
                    "VertexTableIdEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexTableIdEntry {
        static mut instance: ::protobuf::lazy::Lazy<VertexTableIdEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VertexTableIdEntry,
        };
        unsafe {
            instance.get(VertexTableIdEntry::new)
        }
    }
}

impl ::protobuf::Clear for VertexTableIdEntry {
    fn clear(&mut self) {
        self.clear_labelId();
        self.clear_tableId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexTableIdEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexTableIdEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphDefPb {
    // message fields
    pub version: i64,
    pub typeDefs: ::protobuf::RepeatedField<TypeDefPb>,
    pub edgeKinds: ::protobuf::RepeatedField<EdgeKindPb>,
    pub propertyNameToId: ::std::collections::HashMap<::std::string::String, i32>,
    pub labelIdx: i32,
    pub propertyIdx: i32,
    pub vertexTableIds: ::protobuf::RepeatedField<VertexTableIdEntry>,
    pub edgeTableIds: ::protobuf::RepeatedField<EdgeTableIdEntry>,
    pub tableIdx: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphDefPb {
    pub fn new() -> GraphDefPb {
        ::std::default::Default::default()
    }

    // int64 version = 1;

    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = v;
    }

    pub fn get_version(&self) -> i64 {
        self.version
    }

    // repeated .TypeDefPb typeDefs = 2;

    pub fn clear_typeDefs(&mut self) {
        self.typeDefs.clear();
    }

    // Param is passed by value, moved
    pub fn set_typeDefs(&mut self, v: ::protobuf::RepeatedField<TypeDefPb>) {
        self.typeDefs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typeDefs(&mut self) -> &mut ::protobuf::RepeatedField<TypeDefPb> {
        &mut self.typeDefs
    }

    // Take field
    pub fn take_typeDefs(&mut self) -> ::protobuf::RepeatedField<TypeDefPb> {
        ::std::mem::replace(&mut self.typeDefs, ::protobuf::RepeatedField::new())
    }

    pub fn get_typeDefs(&self) -> &[TypeDefPb] {
        &self.typeDefs
    }

    // repeated .EdgeKindPb edgeKinds = 3;

    pub fn clear_edgeKinds(&mut self) {
        self.edgeKinds.clear();
    }

    // Param is passed by value, moved
    pub fn set_edgeKinds(&mut self, v: ::protobuf::RepeatedField<EdgeKindPb>) {
        self.edgeKinds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edgeKinds(&mut self) -> &mut ::protobuf::RepeatedField<EdgeKindPb> {
        &mut self.edgeKinds
    }

    // Take field
    pub fn take_edgeKinds(&mut self) -> ::protobuf::RepeatedField<EdgeKindPb> {
        ::std::mem::replace(&mut self.edgeKinds, ::protobuf::RepeatedField::new())
    }

    pub fn get_edgeKinds(&self) -> &[EdgeKindPb] {
        &self.edgeKinds
    }

    // repeated .GraphDefPb.PropertyNameToIdEntry propertyNameToId = 4;

    pub fn clear_propertyNameToId(&mut self) {
        self.propertyNameToId.clear();
    }

    // Param is passed by value, moved
    pub fn set_propertyNameToId(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.propertyNameToId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_propertyNameToId(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.propertyNameToId
    }

    // Take field
    pub fn take_propertyNameToId(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.propertyNameToId, ::std::collections::HashMap::new())
    }

    pub fn get_propertyNameToId(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.propertyNameToId
    }

    // int32 labelIdx = 5;

    pub fn clear_labelIdx(&mut self) {
        self.labelIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_labelIdx(&mut self, v: i32) {
        self.labelIdx = v;
    }

    pub fn get_labelIdx(&self) -> i32 {
        self.labelIdx
    }

    // int32 propertyIdx = 6;

    pub fn clear_propertyIdx(&mut self) {
        self.propertyIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_propertyIdx(&mut self, v: i32) {
        self.propertyIdx = v;
    }

    pub fn get_propertyIdx(&self) -> i32 {
        self.propertyIdx
    }

    // repeated .VertexTableIdEntry vertexTableIds = 7;

    pub fn clear_vertexTableIds(&mut self) {
        self.vertexTableIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertexTableIds(&mut self, v: ::protobuf::RepeatedField<VertexTableIdEntry>) {
        self.vertexTableIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertexTableIds(&mut self) -> &mut ::protobuf::RepeatedField<VertexTableIdEntry> {
        &mut self.vertexTableIds
    }

    // Take field
    pub fn take_vertexTableIds(&mut self) -> ::protobuf::RepeatedField<VertexTableIdEntry> {
        ::std::mem::replace(&mut self.vertexTableIds, ::protobuf::RepeatedField::new())
    }

    pub fn get_vertexTableIds(&self) -> &[VertexTableIdEntry] {
        &self.vertexTableIds
    }

    // repeated .EdgeTableIdEntry edgeTableIds = 8;

    pub fn clear_edgeTableIds(&mut self) {
        self.edgeTableIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_edgeTableIds(&mut self, v: ::protobuf::RepeatedField<EdgeTableIdEntry>) {
        self.edgeTableIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edgeTableIds(&mut self) -> &mut ::protobuf::RepeatedField<EdgeTableIdEntry> {
        &mut self.edgeTableIds
    }

    // Take field
    pub fn take_edgeTableIds(&mut self) -> ::protobuf::RepeatedField<EdgeTableIdEntry> {
        ::std::mem::replace(&mut self.edgeTableIds, ::protobuf::RepeatedField::new())
    }

    pub fn get_edgeTableIds(&self) -> &[EdgeTableIdEntry] {
        &self.edgeTableIds
    }

    // int64 tableIdx = 9;

    pub fn clear_tableIdx(&mut self) {
        self.tableIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableIdx(&mut self, v: i64) {
        self.tableIdx = v;
    }

    pub fn get_tableIdx(&self) -> i64 {
        self.tableIdx
    }
}

impl ::protobuf::Message for GraphDefPb {
    fn is_initialized(&self) -> bool {
        for v in &self.typeDefs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeKinds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertexTableIds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeTableIds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.typeDefs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edgeKinds)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.propertyNameToId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.labelIdx = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.propertyIdx = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vertexTableIds)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edgeTableIds)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.typeDefs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edgeKinds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(4, &self.propertyNameToId);
        if self.labelIdx != 0 {
            my_size += ::protobuf::rt::value_size(5, self.labelIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.propertyIdx != 0 {
            my_size += ::protobuf::rt::value_size(6, self.propertyIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.vertexTableIds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edgeTableIds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.tableIdx != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tableIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_int64(1, self.version)?;
        }
        for v in &self.typeDefs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edgeKinds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(4, &self.propertyNameToId, os)?;
        if self.labelIdx != 0 {
            os.write_int32(5, self.labelIdx)?;
        }
        if self.propertyIdx != 0 {
            os.write_int32(6, self.propertyIdx)?;
        }
        for v in &self.vertexTableIds {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edgeTableIds {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.tableIdx != 0 {
            os.write_int64(9, self.tableIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphDefPb {
        GraphDefPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "version",
                    |m: &GraphDefPb| { &m.version },
                    |m: &mut GraphDefPb| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeDefPb>>(
                    "typeDefs",
                    |m: &GraphDefPb| { &m.typeDefs },
                    |m: &mut GraphDefPb| { &mut m.typeDefs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                    "edgeKinds",
                    |m: &GraphDefPb| { &m.edgeKinds },
                    |m: &mut GraphDefPb| { &mut m.edgeKinds },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "propertyNameToId",
                    |m: &GraphDefPb| { &m.propertyNameToId },
                    |m: &mut GraphDefPb| { &mut m.propertyNameToId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "labelIdx",
                    |m: &GraphDefPb| { &m.labelIdx },
                    |m: &mut GraphDefPb| { &mut m.labelIdx },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "propertyIdx",
                    |m: &GraphDefPb| { &m.propertyIdx },
                    |m: &mut GraphDefPb| { &mut m.propertyIdx },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexTableIdEntry>>(
                    "vertexTableIds",
                    |m: &GraphDefPb| { &m.vertexTableIds },
                    |m: &mut GraphDefPb| { &mut m.vertexTableIds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeTableIdEntry>>(
                    "edgeTableIds",
                    |m: &GraphDefPb| { &m.edgeTableIds },
                    |m: &mut GraphDefPb| { &mut m.edgeTableIds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tableIdx",
                    |m: &GraphDefPb| { &m.tableIdx },
                    |m: &mut GraphDefPb| { &mut m.tableIdx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphDefPb>(
                    "GraphDefPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphDefPb {
        static mut instance: ::protobuf::lazy::Lazy<GraphDefPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphDefPb,
        };
        unsafe {
            instance.get(GraphDefPb::new)
        }
    }
}

impl ::protobuf::Clear for GraphDefPb {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_typeDefs();
        self.clear_edgeKinds();
        self.clear_propertyNameToId();
        self.clear_labelIdx();
        self.clear_propertyIdx();
        self.clear_vertexTableIds();
        self.clear_edgeTableIds();
        self.clear_tableIdx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphDefPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphDefPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorePropertyPb {
    // message fields
    pub property_id: i32,
    pub property_value: ::protobuf::SingularPtrField<PropertyValuePb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StorePropertyPb {
    pub fn new() -> StorePropertyPb {
        ::std::default::Default::default()
    }

    // int32 property_id = 1;

    pub fn clear_property_id(&mut self) {
        self.property_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_id(&mut self, v: i32) {
        self.property_id = v;
    }

    pub fn get_property_id(&self) -> i32 {
        self.property_id
    }

    // .PropertyValuePb property_value = 2;

    pub fn clear_property_value(&mut self) {
        self.property_value.clear();
    }

    pub fn has_property_value(&self) -> bool {
        self.property_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_property_value(&mut self, v: PropertyValuePb) {
        self.property_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_property_value(&mut self) -> &mut PropertyValuePb {
        if self.property_value.is_none() {
            self.property_value.set_default();
        }
        self.property_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_property_value(&mut self) -> PropertyValuePb {
        self.property_value.take().unwrap_or_else(|| PropertyValuePb::new())
    }

    pub fn get_property_value(&self) -> &PropertyValuePb {
        self.property_value.as_ref().unwrap_or_else(|| PropertyValuePb::default_instance())
    }
}

impl ::protobuf::Message for StorePropertyPb {
    fn is_initialized(&self) -> bool {
        for v in &self.property_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.property_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.property_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.property_id != 0 {
            os.write_int32(1, self.property_id)?;
        }
        if let Some(ref v) = self.property_value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorePropertyPb {
        StorePropertyPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_id",
                    |m: &StorePropertyPb| { &m.property_id },
                    |m: &mut StorePropertyPb| { &mut m.property_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(
                    "property_value",
                    |m: &StorePropertyPb| { &m.property_value },
                    |m: &mut StorePropertyPb| { &mut m.property_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorePropertyPb>(
                    "StorePropertyPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorePropertyPb {
        static mut instance: ::protobuf::lazy::Lazy<StorePropertyPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorePropertyPb,
        };
        unsafe {
            instance.get(StorePropertyPb::new)
        }
    }
}

impl ::protobuf::Clear for StorePropertyPb {
    fn clear(&mut self) {
        self.clear_property_id();
        self.clear_property_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorePropertyPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorePropertyPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorePropertyListPb {
    // message fields
    pub properties: ::protobuf::RepeatedField<StorePropertyPb>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StorePropertyListPb {
    pub fn new() -> StorePropertyListPb {
        ::std::default::Default::default()
    }

    // repeated .StorePropertyPb properties = 1;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<StorePropertyPb>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<StorePropertyPb> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<StorePropertyPb> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[StorePropertyPb] {
        &self.properties
    }
}

impl ::protobuf::Message for StorePropertyListPb {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.properties {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorePropertyListPb {
        StorePropertyListPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorePropertyPb>>(
                    "properties",
                    |m: &StorePropertyListPb| { &m.properties },
                    |m: &mut StorePropertyListPb| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorePropertyListPb>(
                    "StorePropertyListPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorePropertyListPb {
        static mut instance: ::protobuf::lazy::Lazy<StorePropertyListPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorePropertyListPb,
        };
        unsafe {
            instance.get(StorePropertyListPb::new)
        }
    }
}

impl ::protobuf::Clear for StorePropertyListPb {
    fn clear(&mut self) {
        self.clear_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorePropertyListPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorePropertyListPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigPb {
    // message fields
    pub configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConfigPb {
    pub fn new() -> ConfigPb {
        ::std::default::Default::default()
    }

    // repeated .ConfigPb.ConfigsEntry configs = 1;

    pub fn clear_configs(&mut self) {
        self.configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.configs
    }

    // Take field
    pub fn take_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.configs, ::std::collections::HashMap::new())
    }

    pub fn get_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.configs
    }
}

impl ::protobuf::Message for ConfigPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.configs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.configs);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.configs, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigPb {
        ConfigPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "configs",
                    |m: &ConfigPb| { &m.configs },
                    |m: &mut ConfigPb| { &mut m.configs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigPb>(
                    "ConfigPb",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfigPb {
        static mut instance: ::protobuf::lazy::Lazy<ConfigPb> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigPb,
        };
        unsafe {
            instance.get(ConfigPb::new)
        }
    }
}

impl ::protobuf::Clear for ConfigPb {
    fn clear(&mut self) {
        self.clear_configs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpTypePb {
    MARKER = 0,
    OVERWRITE_VERTEX = 1,
    UPDATE_VERTEX = 2,
    DELETE_VERTEX = 3,
    OVERWRITE_EDGE = 4,
    UPDATE_EDGE = 5,
    DELETE_EDGE = 6,
    CREATE_VERTEX_TYPE = 7,
    CREATE_EDGE_TYPE = 8,
    ADD_EDGE_KIND = 9,
    DROP_VERTEX_TYPE = 10,
    DROP_EDGE_TYPE = 11,
    REMOVE_EDGE_KIND = 12,
}

impl ::protobuf::ProtobufEnum for OpTypePb {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpTypePb> {
        match value {
            0 => ::std::option::Option::Some(OpTypePb::MARKER),
            1 => ::std::option::Option::Some(OpTypePb::OVERWRITE_VERTEX),
            2 => ::std::option::Option::Some(OpTypePb::UPDATE_VERTEX),
            3 => ::std::option::Option::Some(OpTypePb::DELETE_VERTEX),
            4 => ::std::option::Option::Some(OpTypePb::OVERWRITE_EDGE),
            5 => ::std::option::Option::Some(OpTypePb::UPDATE_EDGE),
            6 => ::std::option::Option::Some(OpTypePb::DELETE_EDGE),
            7 => ::std::option::Option::Some(OpTypePb::CREATE_VERTEX_TYPE),
            8 => ::std::option::Option::Some(OpTypePb::CREATE_EDGE_TYPE),
            9 => ::std::option::Option::Some(OpTypePb::ADD_EDGE_KIND),
            10 => ::std::option::Option::Some(OpTypePb::DROP_VERTEX_TYPE),
            11 => ::std::option::Option::Some(OpTypePb::DROP_EDGE_TYPE),
            12 => ::std::option::Option::Some(OpTypePb::REMOVE_EDGE_KIND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpTypePb] = &[
            OpTypePb::MARKER,
            OpTypePb::OVERWRITE_VERTEX,
            OpTypePb::UPDATE_VERTEX,
            OpTypePb::DELETE_VERTEX,
            OpTypePb::OVERWRITE_EDGE,
            OpTypePb::UPDATE_EDGE,
            OpTypePb::DELETE_EDGE,
            OpTypePb::CREATE_VERTEX_TYPE,
            OpTypePb::CREATE_EDGE_TYPE,
            OpTypePb::ADD_EDGE_KIND,
            OpTypePb::DROP_VERTEX_TYPE,
            OpTypePb::DROP_EDGE_TYPE,
            OpTypePb::REMOVE_EDGE_KIND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OpTypePb", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OpTypePb {
}

impl ::std::default::Default for OpTypePb {
    fn default() -> Self {
        OpTypePb::MARKER
    }
}

impl ::protobuf::reflect::ProtobufValue for OpTypePb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataTypePb {
    UNKNOWN = 0,
    BOOL = 1,
    CHAR = 2,
    SHORT = 3,
    INT = 4,
    LONG = 5,
    FLOAT = 6,
    DOUBLE = 7,
    STRING = 8,
    BYTES = 9,
    INT_LIST = 10,
    LONG_LIST = 11,
    FLOAT_LIST = 12,
    DOUBLE_LIST = 13,
    STRING_LIST = 14,
}

impl ::protobuf::ProtobufEnum for DataTypePb {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataTypePb> {
        match value {
            0 => ::std::option::Option::Some(DataTypePb::UNKNOWN),
            1 => ::std::option::Option::Some(DataTypePb::BOOL),
            2 => ::std::option::Option::Some(DataTypePb::CHAR),
            3 => ::std::option::Option::Some(DataTypePb::SHORT),
            4 => ::std::option::Option::Some(DataTypePb::INT),
            5 => ::std::option::Option::Some(DataTypePb::LONG),
            6 => ::std::option::Option::Some(DataTypePb::FLOAT),
            7 => ::std::option::Option::Some(DataTypePb::DOUBLE),
            8 => ::std::option::Option::Some(DataTypePb::STRING),
            9 => ::std::option::Option::Some(DataTypePb::BYTES),
            10 => ::std::option::Option::Some(DataTypePb::INT_LIST),
            11 => ::std::option::Option::Some(DataTypePb::LONG_LIST),
            12 => ::std::option::Option::Some(DataTypePb::FLOAT_LIST),
            13 => ::std::option::Option::Some(DataTypePb::DOUBLE_LIST),
            14 => ::std::option::Option::Some(DataTypePb::STRING_LIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataTypePb] = &[
            DataTypePb::UNKNOWN,
            DataTypePb::BOOL,
            DataTypePb::CHAR,
            DataTypePb::SHORT,
            DataTypePb::INT,
            DataTypePb::LONG,
            DataTypePb::FLOAT,
            DataTypePb::DOUBLE,
            DataTypePb::STRING,
            DataTypePb::BYTES,
            DataTypePb::INT_LIST,
            DataTypePb::LONG_LIST,
            DataTypePb::FLOAT_LIST,
            DataTypePb::DOUBLE_LIST,
            DataTypePb::STRING_LIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DataTypePb", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataTypePb {
}

impl ::std::default::Default for DataTypePb {
    fn default() -> Self {
        DataTypePb::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTypePb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TypeEnumPb {
    VERTEX = 0,
    EDGE = 1,
}

impl ::protobuf::ProtobufEnum for TypeEnumPb {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeEnumPb> {
        match value {
            0 => ::std::option::Option::Some(TypeEnumPb::VERTEX),
            1 => ::std::option::Option::Some(TypeEnumPb::EDGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypeEnumPb] = &[
            TypeEnumPb::VERTEX,
            TypeEnumPb::EDGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TypeEnumPb", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TypeEnumPb {
}

impl ::std::default::Default for TypeEnumPb {
    fn default() -> Self {
        TypeEnumPb::VERTEX
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeEnumPb {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ccommon.proto\"r\n\x0bOperationPb\x12\"\n\x0cpartitionKey\x18\x01\
    \x20\x01(\x03R\x0cpartitionKey\x12!\n\x06opType\x18\x02\x20\x01(\x0e2\t.\
    OpTypePbR\x06opType\x12\x1c\n\tdataBytes\x18\x03\x20\x01(\x0cR\tdataByte\
    s\"l\n\x10OperationBatchPb\x12*\n\x10latestSnapshotId\x18\x01\x20\x01(\
    \x03R\x10latestSnapshotId\x12,\n\noperations\x18\x02\x20\x03(\x0b2\x0c.O\
    perationPbR\noperations\"_\n\nLogEntryPb\x12\x1e\n\nsnapshotId\x18\x01\
    \x20\x01(\x03R\nsnapshotId\x121\n\noperations\x18\x02\x20\x01(\x0b2\x11.\
    OperationBatchPbR\noperations\"\x13\n\x11MarkerOperationPb\"L\n\x0fPrope\
    rtyValuePb\x12'\n\x08dataType\x18\x01\x20\x01(\x0e2\x0b.DataTypePbR\x08d\
    ataType\x12\x10\n\x03val\x18\x02\x20\x01(\x0cR\x03val\"\x1c\n\nVertexIdP\
    b\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\"`\n\x08EdgeIdPb\x12!\n\
    \x05srcId\x18\x01\x20\x01(\x0b2\x0b.VertexIdPbR\x05srcId\x12!\n\x05dstId\
    \x18\x02\x20\x01(\x0b2\x0b.VertexIdPbR\x05dstId\x12\x0e\n\x02id\x18\x03\
    \x20\x01(\x03R\x02id\"\x1b\n\tLabelIdPb\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \x05R\x02id\"\x98\x02\n\nEdgeKindPb\x12\x1c\n\tedgeLabel\x18\x01\x20\x01\
    (\tR\tedgeLabel\x12,\n\x0bedgeLabelId\x18\x02\x20\x01(\x0b2\n.LabelIdPbR\
    \x0bedgeLabelId\x12&\n\x0esrcVertexLabel\x18\x03\x20\x01(\tR\x0esrcVerte\
    xLabel\x126\n\x10srcVertexLabelId\x18\x04\x20\x01(\x0b2\n.LabelIdPbR\x10\
    srcVertexLabelId\x12&\n\x0edstVertexLabel\x18\x05\x20\x01(\tR\x0edstVert\
    exLabel\x126\n\x10dstVertexLabelId\x18\x06\x20\x01(\x0b2\n.LabelIdPbR\
    \x10dstVertexLabelId\"\xce\x01\n\x0fDataOperationPb\x12\x18\n\x07keyBlob\
    \x18\x01\x20\x01(\x0cR\x07keyBlob\x12\"\n\x0clocationBlob\x18\x02\x20\
    \x01(\x0cR\x0clocationBlob\x121\n\x05props\x18\x03\x20\x03(\x0b2\x1b.Dat\
    aOperationPb.PropsEntryR\x05props\x1aJ\n\nPropsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x05R\x03key\x12&\n\x05value\x18\x02\x20\x01(\x0b2\x10.\
    PropertyValuePbR\x05value:\x028\x01\":\n\x0fKindOperationPb\x12'\n\x08ed\
    geKind\x18\x01\x20\x01(\x0b2\x0b.EdgeKindPbR\x08edgeKind\"\xb4\x01\n\tTy\
    peDefPb\x12\x1c\n\tversionId\x18\x01\x20\x01(\x05R\tversionId\x12\x14\n\
    \x05label\x18\x02\x20\x01(\tR\x05label\x12$\n\x07labelId\x18\x03\x20\x01\
    (\x0b2\n.LabelIdPbR\x07labelId\x12'\n\x08typeEnum\x18\x04\x20\x01(\x0e2\
    \x0b.TypeEnumPbR\x08typeEnum\x12$\n\x05props\x18\x05\x20\x03(\x0b2\x0e.P\
    ropertyDefPbR\x05props\"\xd6\x01\n\rPropertyDefPb\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x05R\x02id\x12\x18\n\x07innerId\x18\x02\x20\x01(\x05R\x07i\
    nnerId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12'\n\x08dataType\
    \x18\x04\x20\x01(\x0e2\x0b.DataTypePbR\x08dataType\x124\n\x0cdefaultValu\
    e\x18\x05\x20\x01(\x0b2\x10.PropertyValuePbR\x0cdefaultValue\x12\x0e\n\
    \x02pk\x18\x06\x20\x01(\x08R\x02pk\x12\x18\n\x07comment\x18\x07\x20\x01(\
    \tR\x07comment\"M\n\x0cDdlRequestPb\x12!\n\x06opType\x18\x01\x20\x01(\
    \x0e2\t.OpTypePbR\x06opType\x12\x1a\n\x08ddlBytes\x18\x02\x20\x01(\x0cR\
    \x08ddlBytes\"D\n\x11DdlRequestBatchPb\x12/\n\x0bddlRequests\x18\x01\x20\
    \x03(\x0b2\r.DdlRequestPbR\x0bddlRequests\"P\n\x0eDdlOperationPb\x12$\n\
    \rschemaVersion\x18\x01\x20\x01(\x03R\rschemaVersion\x12\x18\n\x07ddlBlo\
    b\x18\x02\x20\x01(\x0cR\x07ddlBlob\"V\n\x12CreateVertexTypePb\x12$\n\x07\
    typeDef\x18\x01\x20\x01(\x0b2\n.TypeDefPbR\x07typeDef\x12\x1a\n\x08table\
    Idx\x18\x02\x20\x01(\x03R\x08tableIdx\"T\n\rAddEdgeKindPb\x12'\n\x08edge\
    Kind\x18\x01\x20\x01(\x0b2\x0b.EdgeKindPbR\x08edgeKind\x12\x1a\n\x08tabl\
    eIdx\x18\x02\x20\x01(\x03R\x08tableIdx\"U\n\x10EdgeTableIdEntry\x12'\n\
    \x08edgeKind\x18\x01\x20\x01(\x0b2\x0b.EdgeKindPbR\x08edgeKind\x12\x18\n\
    \x07tableId\x18\x02\x20\x01(\x03R\x07tableId\"T\n\x12VertexTableIdEntry\
    \x12$\n\x07labelId\x18\x01\x20\x01(\x0b2\n.LabelIdPbR\x07labelId\x12\x18\
    \n\x07tableId\x18\x02\x20\x01(\x03R\x07tableId\"\xdb\x03\n\nGraphDefPb\
    \x12\x18\n\x07version\x18\x01\x20\x01(\x03R\x07version\x12&\n\x08typeDef\
    s\x18\x02\x20\x03(\x0b2\n.TypeDefPbR\x08typeDefs\x12)\n\tedgeKinds\x18\
    \x03\x20\x03(\x0b2\x0b.EdgeKindPbR\tedgeKinds\x12M\n\x10propertyNameToId\
    \x18\x04\x20\x03(\x0b2!.GraphDefPb.PropertyNameToIdEntryR\x10propertyNam\
    eToId\x12\x1a\n\x08labelIdx\x18\x05\x20\x01(\x05R\x08labelIdx\x12\x20\n\
    \x0bpropertyIdx\x18\x06\x20\x01(\x05R\x0bpropertyIdx\x12;\n\x0evertexTab\
    leIds\x18\x07\x20\x03(\x0b2\x13.VertexTableIdEntryR\x0evertexTableIds\
    \x125\n\x0cedgeTableIds\x18\x08\x20\x03(\x0b2\x11.EdgeTableIdEntryR\x0ce\
    dgeTableIds\x12\x1a\n\x08tableIdx\x18\t\x20\x01(\x03R\x08tableIdx\x1aC\n\
    \x15PropertyNameToIdEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value:\x028\x01\"k\n\x0fSto\
    rePropertyPb\x12\x1f\n\x0bproperty_id\x18\x01\x20\x01(\x05R\npropertyId\
    \x127\n\x0eproperty_value\x18\x02\x20\x01(\x0b2\x10.PropertyValuePbR\rpr\
    opertyValue\"G\n\x13StorePropertyListPb\x120\n\nproperties\x18\x01\x20\
    \x03(\x0b2\x10.StorePropertyPbR\nproperties\"x\n\x08ConfigPb\x120\n\x07c\
    onfigs\x18\x01\x20\x03(\x0b2\x16.ConfigPb.ConfigsEntryR\x07configs\x1a:\
    \n\x0cConfigsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01*\x89\x02\n\x08OpTypePb\
    \x12\n\n\x06MARKER\x10\0\x12\x14\n\x10OVERWRITE_VERTEX\x10\x01\x12\x11\n\
    \rUPDATE_VERTEX\x10\x02\x12\x11\n\rDELETE_VERTEX\x10\x03\x12\x12\n\x0eOV\
    ERWRITE_EDGE\x10\x04\x12\x0f\n\x0bUPDATE_EDGE\x10\x05\x12\x0f\n\x0bDELET\
    E_EDGE\x10\x06\x12\x16\n\x12CREATE_VERTEX_TYPE\x10\x07\x12\x14\n\x10CREA\
    TE_EDGE_TYPE\x10\x08\x12\x11\n\rADD_EDGE_KIND\x10\t\x12\x14\n\x10DROP_VE\
    RTEX_TYPE\x10\n\x12\x12\n\x0eDROP_EDGE_TYPE\x10\x0b\x12\x14\n\x10REMOVE_\
    EDGE_KIND\x10\x0c*\xc8\x01\n\nDataTypePb\x12\x0b\n\x07UNKNOWN\x10\0\x12\
    \x08\n\x04BOOL\x10\x01\x12\x08\n\x04CHAR\x10\x02\x12\t\n\x05SHORT\x10\
    \x03\x12\x07\n\x03INT\x10\x04\x12\x08\n\x04LONG\x10\x05\x12\t\n\x05FLOAT\
    \x10\x06\x12\n\n\x06DOUBLE\x10\x07\x12\n\n\x06STRING\x10\x08\x12\t\n\x05\
    BYTES\x10\t\x12\x0c\n\x08INT_LIST\x10\n\x12\r\n\tLONG_LIST\x10\x0b\x12\
    \x0e\n\nFLOAT_LIST\x10\x0c\x12\x0f\n\x0bDOUBLE_LIST\x10\r\x12\x0f\n\x0bS\
    TRING_LIST\x10\x0e*\"\n\nTypeEnumPb\x12\n\n\x06VERTEX\x10\0\x12\x08\n\
    \x04EDGE\x10\x01B!\n\x1dcom.alibaba.maxgraph.proto.v2P\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
